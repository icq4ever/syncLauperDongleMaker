// provision.go
package main

import (
	"bufio"
	"crypto/ed25519"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"syncLauperDongleMaker/internal/config"
)

/*
Usage:
  syncLauperDongleMaker provision
    # interactive: licensee -> choose port -> GET-UID -> summary/confirm -> provision+upload

  syncLauperDongleMaker provision --license out/license.json [--sig out/license.sig] --port /dev/ttyACM0
    # file mode: upload an existing license.json (+ optional license.sig)
    # if --sig omitted, will sign licBytes with prov-priv
*/

func cmdProvision(args []string) {
	fs := flag.NewFlagSet("provision", flag.ExitOnError)

	// file-mode input
	licensePath := fs.String("license", "", "path to license.json (optional; if empty, will issue interactively)")
	sigPath := fs.String("sig", "", "path to license.sig (base64). If empty, will be generated by ProvPriv")

	// interactive issuance (also usable in file-mode)
	licensee := fs.String("licensee", "", "licensee name (interactive if empty)")
	plan := fs.String("plan", "Standard", "license_plan field")
	port := fs.String("port", "", "CDC serial port (e.g. /dev/ttyACM0, COM5)")
	yes := fs.Bool("yes", false, "proceed without interactive confirmation")

	// keys (defaults from internal/config)
	issuerPriv := fs.String("issuer-priv", config.IssuerPrivDefault, "issuer private key (PEM, PKCS#8) for ENTER-PROV auth")
	provPriv := fs.String("prov-priv", config.ProvPrivDefault, "provision private key (PEM, PKCS#8) for license signing")

	_ = fs.Parse(args)

	// ===== 1) choose serial port =====
	p := *port
	if strings.TrimSpace(p) == "" {
		ports := listCDCSerialPorts()
		if len(ports) == 0 {
			fatal("no CDC serial ports found")
		}
		fmt.Println("Select serial port:")
		for i, v := range ports {
			fmt.Printf("  [%d] %s\n", i, v)
		}
		fmt.Print("Enter number [0]: ")
		in := bufio.NewReader(os.Stdin)
		sel := strings.TrimSpace(readLineWithDuration(in))
		if sel == "" {
			sel = "0"
		}
		idx := 0
		fmt.Sscanf(sel, "%d", &idx)
		if idx < 0 || idx >= len(ports) {
			fatal("invalid index")
		}
		p = ports[idx]
	}
	// open serial port and get reader
	s, br := mustOpenSerial(p, 115200)

	// ===== 2) GET-UID =====
	writeLine(s, "GET-UID")
	uid, err := expectUIDLine(br)
	if err != nil {
		fatal("GET-UID: %v", err)
	}
	uid = strings.ToUpper(strings.TrimSpace(uid))
	fmt.Println("UID:", uid)

	// ===== 3) license.json / sig obtain =====
	var licBytes []byte
	var sigB64 []byte

	if strings.TrimSpace(*licensePath) != "" {
		// file mode: read files and (optionally) sign with prov-priv
		b, err := os.ReadFile(*licensePath)
		if err != nil {
			fatal("read license.json: %v", err)
		}
		licBytes = b

		if strings.TrimSpace(*sigPath) != "" {
			sb, err := os.ReadFile(*sigPath)
			if err != nil {
				fatal("read license.sig: %v", err)
			}
			sigB64 = sb
		} else {
			// sign on-the-fly using provPriv
			privProv := mustLoadPriv(*provPriv)
			sig := ed25519.Sign(privProv, licBytes)
			sigB64 = []byte(base64.StdEncoding.EncodeToString(sig))
		}
	} else {
		// interactive issuance
		in := bufio.NewReader(os.Stdin)
		lc := strings.TrimSpace(*licensee)
		for lc == "" {
			fmt.Print("Licensee: ")
			lc = strings.TrimSpace(readLineWithDuration(in))
			if lc == "" {
				fmt.Println("  (required)")
			}
		}
		issued := time.Now().UTC().Format(time.RFC3339Nano)
		serial := sha256Hex(uid + "|" + issued)

		// v2 compact JSON
		lic := struct {
			Version     int    `json:"version"`
			Licensee    string `json:"licensee"`
			LicensePlan string `json:"license_plan"`
			IssuedAt    string `json:"issued_at"`
			SerialKey   string `json:"serial_key"`
		}{
			Version:     2,
			Licensee:    lc,
			LicensePlan: *plan,
			IssuedAt:    issued,
			SerialKey:   serial,
		}
		var err error
		licBytes, err = json.Marshal(lic)
		if err != nil {
			fatal("marshal license: %v", err)
		}

		// sign with provPriv
		privProv := mustLoadPriv(*provPriv)
		sig := ed25519.Sign(privProv, licBytes)
		sigB64 = []byte(base64.StdEncoding.EncodeToString(sig))

		// summary & confirm
		fmt.Println("\nSummary:")
		fmt.Printf("  licensee   : %s\n", lc)
		fmt.Printf("  plan       : %s\n", *plan)
		fmt.Printf("  port       : %s\n", p)
		fmt.Printf("  UID        : %s\n", uid)
		printIssuedUTCandKST("issued_at", parseRFC3339Z(issued))
		fmt.Printf("  serial_key : %s\n", serial)
		if !*yes {
			fmt.Print("\nProceed? (y/N): ")
			confirm := strings.ToLower(strings.TrimSpace(readLineWithDuration(in)))
			if confirm != "y" && confirm != "yes" {
				fatal("aborted by user")
			}
		}
	}

	// ===== 4) Request device challenge (REQ-PROV) and ENTER-PROV =====
	// Ask device to generate nonce
	writeLine(s, "REQ-PROV")

	// wait for "CHAL <nonce>" (waitFor treats "DBG:" lines specially)
	chalLine, err := waitFor(br, 5*time.Second, "CHAL ")
	if err != nil {
		fatal("REQ-PROV: %v", err)
	}
	// Extract nonce text
	nonce := strings.TrimSpace(strings.TrimPrefix(chalLine, "CHAL"))
	nonce = strings.TrimSpace(nonce)
	if nonce == "" {
		fatal("REQ-PROV: empty nonce received")
	}

	// Build message and sign with issuer private key
	msg := nonce + "|" + uid + "|ENTER-PROV"
	privIssuer := mustLoadPriv(*issuerPriv)
	sigAuth := ed25519.Sign(privIssuer, []byte(msg))
	sigAuthB64 := base64.StdEncoding.EncodeToString(sigAuth)

	writeLine(s, "ENTER-PROV "+nonce+" "+sigAuthB64)
	if err := expectOK(br); err != nil {
		fatal("ENTER-PROV: %v", err)
	}

	// ===== 5) PUT LICENSE / PUT SIG / COMMIT =====
	writeLine(s, fmt.Sprintf("PUT LICENSE %d", len(licBytes)))
	if err := expectReady(br); err != nil {
		fatal("PUT LICENSE: %v", err)
	}
	if err := writeExact(s, licBytes); err != nil {
		fatal("write license: %v", err)
	}
	if err := expectWrote(br); err != nil {
		fatal("after license: %v", err)
	}

	writeLine(s, fmt.Sprintf("PUT SIG %d", len(sigB64)))
	if err := expectReady(br); err != nil {
		fatal("PUT SIG: %v", err)
	}
	if err := writeExact(s, sigB64); err != nil {
		fatal("write sig: %v", err)
	}
	if err := expectWrote(br); err != nil {
		fatal("after sig: %v", err)
	}

	writeLine(s, "COMMIT")
	if err := expectRebooting(br); err != nil {
		fatal("COMMIT: %v", err)
	}

	// ===== 6) optional local backup =====
	_ = os.MkdirAll("out", 0755)
	tag := time.Now().Format("20060102T150405")
	_ = os.WriteFile(filepath.Join("out", "license-"+tag+".json"), licBytes, 0644)
	_ = os.WriteFile(filepath.Join("out", "license-"+tag+".sig"), sigB64, 0644)

	fmt.Println("\nprovision: DONE")
}