// provision.go — updated to PUT lowercase filenames (license.json / license.sig)
package main

import (
	"bufio"
	"crypto/ed25519"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"syncLauperDongleMaker/internal/binding"
	"syncLauperDongleMaker/internal/config"
)

/*
Burn command for RP2350 dongles (CDC control channel).
*/

func cmdBurn(args []string) {
	fs := flag.NewFlagSet("burn", flag.ExitOnError)

	licensePath := fs.String("license", "", "path to license.json (optional; if empty, will issue interactively)")
	sigPath := fs.String("sig", "", "path to license.sig (base64). If empty, will be generated by ProvPriv")

	licensee := fs.String("licensee", "", "licensee name (interactive if empty)")
	plan := fs.String("plan", "Standard", "license_plan field")
	port := fs.String("port", "", "CDC serial port (e.g. /dev/ttyACM0, COM5)")
	yes := fs.Bool("yes", false, "proceed without interactive confirmation")

	issuerPriv := fs.String("issuer-priv", config.IssuerPrivDefault, "issuer private key (PEM, PKCS#8) for ENTER-PROV auth")
	provPriv := fs.String("prov-priv", config.ProvPrivDefault, "provision private key (PEM, PKCS#8) for license signing")

	_ = fs.Parse(args)

	// 1) select port
	p := *port
	if strings.TrimSpace(p) == "" {
		ports := listCDCSerialPorts()
		if len(ports) == 0 {
			fatal("no CDC serial ports found")
		}
		fmt.Println("Select serial port:")
		for i, v := range ports {
			fmt.Printf("  [%d] %s\n", i, v)
		}
		fmt.Print("Enter number [0]: ")
		in := bufio.NewReader(os.Stdin)
		sel := strings.TrimSpace(readLineWithDuration(in))
		if sel == "" {
			sel = "0"
		}
		idx := 0
		fmt.Sscanf(sel, "%d", &idx)
		if idx < 0 || idx >= len(ports) {
			fatal("invalid index")
		}
		p = ports[idx]
	}
	// open serial
	s, br := mustOpenSerial(p, 115200)

	// 2) GET-UID
	writeLine(s, "GET-UID")
	uid, err := expectUIDLine(br)
	if err != nil {
		fatal("GET-UID: %v", err)
	}
	uid = strings.ToUpper(strings.TrimSpace(uid))
	fmt.Println("UID:", uid)

	// 2.5) GET-BINDING - collect partition binding info
	writeLine(s, "GET-BINDING")
	bindingLine, err := expectBindingLine(br)
	if err != nil {
		fatal("GET-BINDING: %v", err)
	}
	remoteSnap := parseBindingLine(bindingLine)
	bindingKey := binding.BuildKeyV2(remoteSnap, uid)
	fmt.Println("Binding:", bindingKey)

	// 3) license / sig acquire
	var licBytes []byte
	var sigBytes []byte

	if strings.TrimSpace(*licensePath) != "" {
		// file mode
		b, err := os.ReadFile(*licensePath)
		if err != nil {
			fatal("read license.json: %v", err)
		}
		licBytes = b

		if strings.TrimSpace(*sigPath) != "" {
			sb, err := os.ReadFile(*sigPath)
			if err != nil {
				fatal("read license.sig: %v", err)
			}
			// sig 파일이 base64인지 바이너리인지 자동 판별
			sigBytes, err = decodeSignature(sb)
			if err != nil {
				fatal("decode signature: %v", err)
			}
		} else {
			// sign with provPriv
			privProv := mustLoadPriv(*provPriv)
			sigBytes = ed25519.Sign(privProv, licBytes)
		}
	} else {
		// interactive issue
		in := bufio.NewReader(os.Stdin)
		lc := strings.TrimSpace(*licensee)
		for lc == "" {
			fmt.Print("Licensee: ")
			// Use standard ReadString instead of readLineWithDuration for stdin
			line, err := in.ReadString('\n')
			if err != nil {
				if err == io.EOF {
					break
				}
				continue
			}
			lc = strings.TrimSpace(line)
			if lc == "" {
				fmt.Println("  (required)")
			}
		}
		issued := time.Now().UTC()
		serial := sha256Hex(bindingKey + "|" + issued.Format(time.RFC3339))

		lic := struct {
			Version     int       `json:"version"`
			Licensee    string    `json:"licensee"`
			LicensePlan string    `json:"license_plan"`
			IssuedAt    time.Time `json:"issued_at"`
			SerialKey   string    `json:"serial_key"`
		}{
			Version:     2,
			Licensee:    lc,
			LicensePlan: *plan,
			IssuedAt:    issued,
			SerialKey:   serial,
		}
		var err error
		licBytes, err = json.MarshalIndent(lic, "", "  ")
		if err != nil {
			fatal("marshal license: %v", err)
		}

		// sign with provPriv
		privProv := mustLoadPriv(*provPriv)
		sigBytes = ed25519.Sign(privProv, licBytes)

		// summary & confirm
		fmt.Println("\nSummary:")
		fmt.Printf("  licensee   : %s\n", lc)
		fmt.Printf("  plan       : %s\n", *plan)
		fmt.Printf("  port       : %s\n", p)
		fmt.Printf("  UID        : %s\n", uid)
		printIssuedUTCandKST("issued_at", issued)
		fmt.Printf("  serial_key : %s\n", serial)
		if !*yes {
			fmt.Print("\nProceed? (y/N): ")
			confirm := strings.ToLower(strings.TrimSpace(readLineWithDuration(in)))
			if confirm != "y" && confirm != "yes" {
				fatal("aborted by user")
			}
		}
	}

	// 4) REQ-PROV -> CHAL -> ENTER-PROV
	writeLine(s, "REQ-PROV")

	// readChallenge helper (accept DBG: CHAL=... or CHAL ...)
	readChallenge := func(br *bufio.Reader, timeout time.Duration) (string, error) {
		deadline := time.Now().Add(timeout)
		for time.Now().Before(deadline) {
			l := strings.TrimSpace(readLineWithDuration(br, 2*time.Second))
			if l == "" {
				continue
			}
			if strings.HasPrefix(l, "DBG:") {
				fmt.Println("[DEV]", l)
				if idx := strings.Index(l, "CHAL"); idx >= 0 {
					rest := l[idx+4:]
					rest = strings.TrimLeft(rest, " =:\t")
					parts := strings.Fields(rest)
					if len(parts) > 0 && parts[0] != "" {
						return parts[0], nil
					}
				}
				continue
			}
			if strings.HasPrefix(l, "CHAL") {
				rest := strings.TrimSpace(strings.TrimPrefix(l, "CHAL"))
				if rest != "" {
					return rest, nil
				}
			}
		}
		return "", fmt.Errorf("timeout waiting for CHAL")
	}

	nonce, err := readChallenge(br, 6*time.Second)
	if err != nil {
		fatal("REQ-PROV: %v", err)
	}
	fmt.Printf("[DEV] got CHAL=%s\n", nonce)

	// build message and sign with issuer private key
	msg := nonce + "|" + uid + "|ENTER-PROV"
	privIssuer := mustLoadPriv(*issuerPriv)
	sigAuth := ed25519.Sign(privIssuer, []byte(msg))
	sigAuthB64 := base64.StdEncoding.EncodeToString(sigAuth)

	// send ENTER-PROV
	writeLine(s, "ENTER-PROV "+nonce+" "+sigAuthB64)

	// wait OK/ERR
	waitOKorErr := func(br *bufio.Reader, timeout time.Duration) error {
		deadline := time.Now().Add(timeout)
		for time.Now().Before(deadline) {
			l := strings.TrimSpace(readLineWithDuration(br, 2*time.Second))
			if l == "" {
				continue
			}
			if strings.HasPrefix(l, "DBG:") {
				fmt.Println("[DEV]", l)
				continue
			}
			if l == "OK" || strings.HasPrefix(l, "OK:") {
				return nil
			}
			if strings.HasPrefix(l, "ERR:") {
				return fmt.Errorf("%s", strings.TrimPrefix(l, "ERR:"))
			}
		}
		return fmt.Errorf("timeout waiting for OK")
	}

	if err := waitOKorErr(br, 6*time.Second); err != nil {
		fatal("ENTER-PROV: %v", err)
	}

	// 5) PUT license.json / PUT license.sig / COMMIT  (lowercase filenames)
	writeLine(s, fmt.Sprintf("PUT license.json %d", len(licBytes)))
	if err := expectReady(br); err != nil {
		fatal("PUT license.json: %v", err)
	}
	if err := writeExact(s, licBytes); err != nil {
		fatal("write license: %v", err)
	}
	if err := expectWrote(br); err != nil {
		fatal("after license: %v", err)
	}

	writeLine(s, fmt.Sprintf("PUT license.sig %d", len(sigBytes)))
	if err := expectReady(br); err != nil {
		fatal("PUT license.sig: %v", err)
	}
	if err := writeExact(s, sigBytes); err != nil {
		fatal("write sig: %v", err)
	}
	if err := expectWrote(br); err != nil {
		fatal("after sig: %v", err)
	}

	writeLine(s, "COMMIT")
	if err := expectRebootOrDisconnect(br, p, 20*time.Second); err != nil {
		fatal("COMMIT: %v", err)
	}

	// 6) local backup
	_ = os.MkdirAll("out", 0755)
	tag := time.Now().Format("20060102T150405")
	_ = os.WriteFile(filepath.Join("out", "license-"+tag+".json"), licBytes, 0644)
	_ = os.WriteFile(filepath.Join("out", "license-"+tag+".sig"), sigBytes, 0644)

	fmt.Println("\nprovision: DONE")
}
