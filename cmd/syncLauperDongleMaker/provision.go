package main

import (
	"bufio"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"encoding/pem"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"time"

	"syncLauperDongleMaker/internal/config"

	"github.com/tarm/serial"
)

/*
Usage (하나의 커맨드로 통합):
  syncLauperDongleMaker provision
    # 대화형: licensee 입력 → 포트 선택 → UID → 요약/확인 → 발급+업로드

  syncLauperDongleMaker provision --license out/license.json [--sig out/license.sig] --port /dev/ttyACM0
    # 파일 모드: 이미 존재하는 라이선스(및 서명) 업로드
    # --sig 생략 시 ProvPriv로 즉석 서명
*/

func cmdProvision(args []string) {
	fs := flag.NewFlagSet("provision", flag.ExitOnError)

	// 파일모드 입력
	licensePath := fs.String("license", "", "path to license.json (optional; if empty, will issue interactively)")
	sigPath     := fs.String("sig",     "", "path to license.sig (base64). If empty, will be generated by ProvPriv")

	// 대화형 발급용(파일모드에도 사용 가능)
	licensee := fs.String("licensee", "", "licensee name (interactive if empty)")
	plan     := fs.String("plan", "Standard", "license_plan field")
	port     := fs.String("port", "", "CDC serial port (e.g. /dev/ttyACM0, COM5)")
	yes      := fs.Bool("yes", false, "proceed without interactive confirmation")

	// 키 경로 (기본값은 config.*Default)
	issuerPriv := fs.String("issuer-priv", config.IssuerPrivDefault, "issuer private key (PEM, PKCS#8) for ENTER-PROV auth")
	provPriv   := fs.String("prov-priv",   config.ProvPrivDefault,   "provision private key (PEM, PKCS#8) for license signing")

	_ = fs.Parse(args)

	// ===== 1) 시리얼 포트 선택/확정 =====
	p := *port
	if strings.TrimSpace(p) == "" {
		ports := listCDCSerialPorts()
		if len(ports) == 0 { die("no CDC serial ports found") }
		fmt.Println("Select serial port:")
		for i, v := range ports { fmt.Printf("  [%d] %s\n", i, v) }
		fmt.Print("Enter number [0]: ")
		in := bufio.NewReader(os.Stdin)
		sel := strings.TrimSpace(readLineWithDuration(in))
		if sel == "" { sel = "0" }
		idx := 0; fmt.Sscanf(sel, "%d", &idx)
		if idx < 0 || idx >= len(ports) { die("invalid index") }
		p = ports[idx]
	}
	// 포트 열고 배너 비우기
	s, br := mustOpenSerial(p, 115200)

	// ===== 2) UID 조회 =====
	writeLine(s, "GET-UID")
	uid, err := expectUIDLine(br)
	if err != nil { die("GET-UID: %v", err) }
	uid = strings.ToUpper(strings.TrimSpace(uid))
	fmt.Println("UID:", uid)

	// ===== 3) license.json / sig 확보 =====
	var licBytes []byte
	var sigB64 []byte

	if strings.TrimSpace(*licensePath) != "" {
		// 파일모드
		b, err := os.ReadFile(*licensePath)
		if err != nil { die("read license.json: %v", err) }
		licBytes = b

		if strings.TrimSpace(*sigPath) != "" {
			sb, err := os.ReadFile(*sigPath)
			if err != nil { die("read license.sig: %v", err) }
			sigB64 = sb
		} else {
			// 즉석 서명
			privProv := mustLoadPriv(*provPriv)
			sig := ed25519.Sign(privProv, licBytes)
			sigB64 = []byte(base64.StdEncoding.EncodeToString(sig))
		}
	} else {
		// 대화형 발급
		in := bufio.NewReader(os.Stdin)
		lc := strings.TrimSpace(*licensee)
		for lc == "" {
			fmt.Print("Licensee: ")
			lc = strings.TrimSpace(readLineWithDuration(in))
			if lc == "" { fmt.Println("  (required)") }
		}
		issued := time.Now().UTC().Format(time.RFC3339Nano) // 나노초 9자리
		serial := sha256Hex(uid + "|" + issued)

		// v2: issued_at은 문자열(나노초 9자리), compact JSON(서명 바이트 안정)
		lic := struct {
			Version     int    `json:"version"`
			Licensee    string `json:"licensee"`
			LicensePlan string `json:"license_plan"`
			IssuedAt    string `json:"issued_at"`
			SerialKey   string `json:"serial_key"`
		}{
			Version:     2,
			Licensee:    lc,
			LicensePlan: *plan,
			IssuedAt:    issued,
			SerialKey:   serial,
		}
		var err error
		licBytes, err = json.Marshal(lic) // minify for deterministic signature
		if err != nil { die("marshal license: %v", err) }

		// ProvPriv로 서명 → base64
		privProv := mustLoadPriv(*provPriv)
		sig := ed25519.Sign(privProv, licBytes)
		sigB64 = []byte(base64.StdEncoding.EncodeToString(sig))

		// 요약 & 확인
		fmt.Println("\nSummary:")
		fmt.Printf("  licensee   : %s\n", lc)
		fmt.Printf("  plan       : %s\n", *plan)
		fmt.Printf("  port       : %s\n", p)
		fmt.Printf("  UID        : %s\n", uid)
		printIssuedUTCandKST("issued_at", parseRFC3339Z(issued))
		fmt.Printf("  serial_key : %s\n", serial)
		if !*yes {
			fmt.Print("\nProceed? (y/N): ")
			confirm := strings.ToLower(strings.TrimSpace(readLineWithDuration(in)))
			if confirm != "y" && confirm != "yes" {
				die("aborted by user")
			}
		}
	}

	// ===== 4) CHALLENGE-RESPONSE: request device nonce (REQ-PROV) and sign it =====
	// Ask device to produce a nonce (device-side TRNG) and return "CHAL <noncehex>"
	writeLine(s, "REQ-PROV")

	// waitFor handles DBG: lines (it prints them as [DEV] ...), and will return a line
	// that equals or starts with "CHAL" (because we pass "CHAL" as a want).
	chalLine, err := waitFor(br, 5*time.Second, "CHAL")
	if err != nil {
		die("REQ-PROV: %v", err)
	}
	// chalLine is expected like "CHAL 3A2FFED6..."
	// extract nonce after the space
	var nonce string
	if strings.HasPrefix(chalLine, "CHAL ") {
		nonce = strings.TrimSpace(chalLine[len("CHAL "):])
	} else if strings.HasPrefix(chalLine, "CHAL\t") {
		nonce = strings.TrimSpace(chalLine[len("CHAL\t"):])
	} else {
		// defensive: if waitFor matched via prefix, the line might be exactly "CHAL" (no nonce)
		// treat that as error
		die("REQ-PROV: unexpected CHAL format: %q", chalLine)
	}
	if nonce == "" {
		die("REQ-PROV: empty nonce")
	}
	// optional: sanity-check nonce length (hex). permit flexible length.
	if len(nonce) > 256 {
		die("REQ-PROV: nonce too long")
	}

	// Build the message the device expects and sign with issuer private key.
	// NOTE: device constructs the same msg = nonce + "|" + UID + "|ENTER-PROV"
	msg := nonce + "|" + uid + "|ENTER-PROV"

	// load issuer private key (host-side). This is the key whose pubkey/device has in OTP.
	privIssuer := mustLoadPriv(*issuerPriv)
	sigAuth := ed25519.Sign(privIssuer, []byte(msg))
	sigAuthB64 := base64.StdEncoding.EncodeToString(sigAuth)

	// send ENTER-PROV <nonce> <sigB64>
	writeLine(s, "ENTER-PROV "+nonce+" "+sigAuthB64)
	if err := expectOK(br); err != nil { die("ENTER-PROV: %v", err) }

	// ===== 5) PUT LICENSE / PUT SIG / COMMIT =====
	writeLine(s, fmt.Sprintf("PUT LICENSE %d", len(licBytes)))
	if err := expectReady(br); err != nil { die("PUT LICENSE: %v", err) }
	if err := writeExact(s, licBytes); err != nil { die("write license: %v", err) }
	if err := expectWrote(br); err != nil { die("after license: %v", err) }

	writeLine(s, fmt.Sprintf("PUT SIG %d", len(sigB64)))
	if err := expectReady(br); err != nil { die("PUT SIG: %v", err) }
	if err := writeExact(s, sigB64); err != nil { die("write sig: %v", err) }
	if err := expectWrote(br); err != nil { die("after sig: %v", err) }

	writeLine(s, "COMMIT")
	if err := expectRebooting(br); err != nil { die("COMMIT: %v", err) }

	// ===== 6) 로컬 백업 저장(선택) =====
	_ = os.MkdirAll("out", 0755)
	tag := time.Now().Format("20060102T150405")
	_ = os.WriteFile(filepath.Join("out", "license-"+tag+".json"), licBytes, 0644)
	_ = os.WriteFile(filepath.Join("out", "license-"+tag+".sig"),  sigB64,   0644)

	fmt.Println("\nprovision: DONE")
}

/* ======== Serial helpers (이 파일 내부에 통합) ======== */

func mustOpenSerial(port string, baud int) (*serial.Port, *bufio.Reader) {
	c := &serial.Config{Name: port, Baud: baud, ReadTimeout: 2 * time.Second}
	s, err := serial.OpenPort(c)
	if err != nil { die("open serial %s: %v", port, err) }
	br := bufio.NewReader(s)
	_ = s.Flush()
	return s, br
}

func writeLine(w io.Writer, s string) {
	io.WriteString(w, s)
	io.WriteString(w, "\n")
}
func writeExact(w io.Writer, b []byte) error {
	n, err := w.Write(b)
	if err != nil { return err }
	if n != len(b) { return io.ErrShortWrite }
	return nil
}

func readLineWithDuration(r *bufio.Reader, d ...time.Duration) string {
	timeout := 5 * time.Second
	if len(d) > 0 && d[0] > 0 { timeout = d[0] }

	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	type resp struct{ line string; err error }
	ch := make(chan resp, 1)
	go func() {
		line, err := r.ReadString('\n')
		ch <- resp{line: line, err: err}
	}()
	select {
	case <-ctx.Done():
		return ""
	case x := <-ch:
		if x.err != nil { return "" }
		return strings.TrimSpace(x.line)
	}
}

func expectUIDLine(r *bufio.Reader) (string, error) {
	for i := 0; i < 8; i++ { // 여유 있게 몇 번 더 시도
		l := strings.TrimSpace(readLineWithDuration(r, 2*time.Second))
		return strings.ToUpper(l), nil
		
		// 그 외(빈 줄, 배너, 구버전 "UID XXXXX" 등)는 무시하고 계속
	}
	return "", errors.New("UID not received")
}

// 줄을 계속 받아보며, wants 중 하나(완전일치 또는 접두사)가 나올 때까지 대기.
// "DBG:"로 시작하는 라인은 중계만 하고 건너뜁니다.
func waitFor(r *bufio.Reader, timeout time.Duration, wants ...string) (string, error) {
	deadline := time.Now().Add(timeout)
	for time.Now().Before(deadline) {
		l := strings.TrimSpace(readLineWithDuration(r, 2*time.Second))
		if l == "" {
			continue
		}
		if strings.HasPrefix(l, "DBG:") {
			fmt.Println("[DEV]", l) // 원하면 주석처리 가능
			continue
		}
		for _, w := range wants {
			if l == w || strings.HasPrefix(l, w) {
				return l, nil
			}
		}
		// 배너/기타 라인은 무시하고 계속
	}
	return "", fmt.Errorf("timeout waiting for %v", wants)
}


func expectOK(r *bufio.Reader) error {
	_, err := waitFor(r, 5*time.Second, "OK")
	return err
}
func expectReady(r *bufio.Reader) error {
	_, err := waitFor(r, 5*time.Second, "OK:READY")
	return err
}
func expectWrote(r *bufio.Reader) error {
	_, err := waitFor(r, 5*time.Second, "OK:WROTE") // 접두사 허용됨
	return err
}
func expectRebooting(r *bufio.Reader) error {
	_, err := waitFor(r, 8*time.Second, "OK:REBOOTING", "OK")
	return err
}


/* ======== Port scan ======== */

func listCDCSerialPorts() []string {
	var globs []string
	switch runtime.GOOS {
	case "linux":
		globs = []string{"/dev/ttyACM*", "/dev/ttyUSB*"}
	case "darwin":
		globs = []string{"/dev/tty.usbmodem*", "/dev/tty.usbserial*"}
	case "windows":
		// 간단 스캔
		var ports []string
		for i := 1; i <= 40; i++ {
			ports = append(ports, fmt.Sprintf("COM%d", i))
		}
		return ports
	default:
		globs = []string{"/dev/ttyACM*", "/dev/ttyUSB*"}
	}
	m := map[string]bool{}
	for _, g := range globs {
		ms, _ := filepath.Glob(g)
		for _, p := range ms { m[p] = true }
	}
	ports := make([]string, 0, len(m))
	for p := range m { ports = append(ports, p) }
	sort.Strings(ports)
	return ports
}

/* ======== Misc ======== */

func mustLoadPriv(path string) ed25519.PrivateKey {
	b, err := os.ReadFile(path)
	if err != nil { die("read key %s: %v", path, err) }
	for {
		blk, rest := pem.Decode(b)
		if blk == nil { break }
		if blk.Type == "PRIVATE KEY" {
			k, err := x509.ParsePKCS8PrivateKey(blk.Bytes)
			if err != nil { die("parse %s: %v", path, err) }
			if p, ok := k.(ed25519.PrivateKey); ok { return p }
			die("%s is not Ed25519 private key", path)
		}
		b = rest
	}
	die("no PRIVATE KEY block in %s", path)
	return nil
}

func sha256Hex(s string) string {
	sum := sha256.Sum256([]byte(s))
	return hex.EncodeToString(sum[:])
}

func randomNonceHex(nBytes int) string {
	if nBytes <= 0 { nBytes = 12 }
	buf := make([]byte, nBytes)
	_, _ = rand.Read(buf)
	return strings.ToUpper(hex.EncodeToString(buf))
}

func parseRFC3339Z(s string) time.Time {
	t, _ := time.Parse(time.RFC3339Nano, s)
	return t
}
func printIssuedUTCandKST(label string, t time.Time){
	utc := t.UTC().Format(time.RFC3339)
	loc, _ := time.LoadLocation("Asia/Seoul")
	kst := t.In(loc).Format(time.RFC3339)
	fmt.Printf("  %-10s = UTC %s\n", label, utc)
	fmt.Printf("               KST %s\n", kst)
}

func die(fmtStr string, a ...any) {
	fmt.Fprintf(os.Stderr, "ERROR: "+fmtStr+"\n", a...)
	os.Exit(1)
}
