// provision.go â€” challenge-response based provisioning (REQ-PROV / ENTER-PROV)
// Replace/put this in cmd/syncLauperDongleMaker/provision.go (or project root as appropriate)
package main

import (
	"bufio"
	"crypto/ed25519"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"syncLauperDongleMaker/internal/config"
	"syncLauperDongleMaker/internal/rp"

)

/*
Usage:
  syncLauperDongleMaker upload [--port /dev/ttyACM0] [--license path/to/license.json] [--sig path/to/sig.b64]
If --license omitted, the tool will issue a license interactively (licensee prompt).
If --sig omitted in file-mode, prov-priv is used to sign the license (base64-encoded signature).
*/

func cmdProvision(args []string) {
	fs := flag.NewFlagSet("provision", flag.ExitOnError)

	licensePath := fs.String("license", "", "path to license.json (optional; if empty, will issue interactively)")
	sigPath     := fs.String("sig",     "", "path to license.sig (base64). If empty, will be generated by ProvPriv")

	licensee := fs.String("licensee", "", "licensee name (interactive if empty)")
	plan     := fs.String("plan", "Standard", "license_plan field")
	port     := fs.String("port", "", "CDC serial port (e.g. /dev/ttyACM0, COM5)")
	yes      := fs.Bool("yes", false, "proceed without interactive confirmation")

	issuerPriv := fs.String("issuer-priv", config.IssuerPrivDefault, "issuer private key (PEM, PKCS#8) for ENTER-PROV auth")
	provPriv   := fs.String("prov-priv",   config.ProvPrivDefault,   "provision private key (PEM, PKCS#8) for license signing")

	_ = fs.Parse(args)

	// pick serial port
	p := *port
	if strings.TrimSpace(p) == "" {
		ports := rp.ListCDCSerialPorts()
		if len(ports) == 0 { fatal("no CDC serial ports found") }
		fmt.Println("Select serial port:")
		for i, v := range ports { fmt.Printf("  [%d] %s\n", i, v) }
		fmt.Print("Enter number [0]: ")
		in := bufio.NewReader(os.Stdin)
		sel := strings.TrimSpace(readLineWithDuration(in))
		if sel == "" { sel = "0" }
		idx := 0; fmt.Sscanf(sel, "%d", &idx)
		if idx < 0 || idx >= len(ports) { fatal("invalid index") }
		p = ports[idx]
	}

	// open serial
	s, br := mustOpenSerial(p, 115200)

	// GET-UID
	writeLine(s, "GET-UID")
	uid, err := expectUIDLine(br)
	if err != nil { fatal("GET-UID: %v", err) }
	uid = strings.ToUpper(strings.TrimSpace(uid))
	fmt.Println("UID:", uid)

	// Prepare license bytes and signature (sigB64)
	var licBytes []byte
	var sigB64 []byte

	if strings.TrimSpace(*licensePath) != "" {
		// file mode
		b, err := os.ReadFile(*licensePath)
		if err != nil { fatal("read license.json: %v", err) }
		licBytes = b

		if strings.TrimSpace(*sigPath) != "" {
			sb, err := os.ReadFile(*sigPath)
			if err != nil { fatal("read license.sig: %v", err) }
			// allow file to include newline; trim
			sigB64 = []byte(strings.TrimSpace(string(sb)))
		} else {
			// sign with provisioner private key, base64-encode
			privProv := mustLoadPriv(*provPriv)
			sig := ed25519.Sign(privProv, licBytes)
			sigB64 = []byte(base64.StdEncoding.EncodeToString(sig))
		}
	} else {
		// interactive issue
		in := bufio.NewReader(os.Stdin)
		lc := strings.TrimSpace(*licensee)
		for lc == "" {
			fmt.Print("Licensee: ")
			lc = strings.TrimSpace(readLineWithDuration(in))
			if lc == "" { fmt.Println("  (required)") }
		}

		issuedTime := time.Now().UTC()
		issued := issuedTime.UTC().Format(time.RFC3339Nano) // RFC3339Nano for deterministic precision
		serial := sha256Hex(uid + "|" + issued)

		licStruct := struct {
			Version     int    `json:"version"`
			Licensee    string `json:"licensee"`
			LicensePlan string `json:"license_plan"`
			IssuedAt    string `json:"issued_at"`
			SerialKey   string `json:"serial_key"`
		}{
			Version:     2,
			Licensee:    lc,
			LicensePlan: *plan,
			IssuedAt:    issued,
			SerialKey:   serial,
		}
		var merr error
		licBytes, merr = json.Marshal(licStruct)
		if merr != nil { fatal("marshal license: %v", merr) }

		// sign with provPriv (provisioner private)
		privProv := mustLoadPriv(*provPriv)
		sig := ed25519.Sign(privProv, licBytes)
		sigB64 = []byte(base64.StdEncoding.EncodeToString(sig))

		// summary & confirmation
		fmt.Println("\nSummary:")
		fmt.Printf("  licensee   : %s\n", lc)
		fmt.Printf("  plan       : %s\n", *plan)
		fmt.Printf("  port       : %s\n", p)
		fmt.Printf("  UID        : %s\n", uid)
		printIssuedUTCandKST("issued_at", issuedTime)
		fmt.Printf("  serial_key : %s\n", serial)
		if !*yes {
			fmt.Print("\nProceed? (y/N): ")
			confirm := strings.ToLower(strings.TrimSpace(readLineWithDuration(in)))
			if confirm != "y" && confirm != "yes" {
				fatal("aborted by user")
			}
		}
	}

	// ===== Challenge-response: REQ-PROV -> expect CHAL <nonce> =====
	writeLine(s, "REQ-PROV")
	l, err := waitFor(br, 5*time.Second, "CHAL")
	if err != nil { fatal("REQ-PROV: %v", err) }

	// parse nonce
	var nonce string
	if strings.HasPrefix(l, "CHAL") {
		nonce = strings.TrimSpace(strings.TrimPrefix(l, "CHAL"))
	} else {
		fatal("unexpected CHAL response: %q", l)
	}
	if nonce == "" { fatal("empty nonce from device") }

	// construct message and sign with issuerPriv
	msg := nonce + "|" + uid + "|ENTER-PROV"
	privIssuer := mustLoadPriv(*issuerPriv)
	sigAuth := ed25519.Sign(privIssuer, []byte(msg))
	sigAuthB64 := base64.StdEncoding.EncodeToString(sigAuth)

	// send ENTER-PROV
	writeLine(s, "ENTER-PROV "+nonce+" "+sigAuthB64)
	if err := expectOK(br); err != nil { fatal("ENTER-PROV: %v", err) }

	// ===== PUT LICENSE / PUT SIG / COMMIT =====
	writeLine(s, fmt.Sprintf("PUT LICENSE %d", len(licBytes)))
	if err := expectReady(br); err != nil { fatal("PUT LICENSE: %v", err) }
	if err := writeExact(s, licBytes); err != nil { fatal("write license: %v", err) }
	if err := expectWrote(br); err != nil { fatal("after license: %v", err) }

	writeLine(s, fmt.Sprintf("PUT SIG %d", len(sigB64)))
	if err := expectReady(br); err != nil { fatal("PUT SIG: %v", err) }
	if err := writeExact(s, sigB64); err != nil { fatal("write sig: %v", err) }
	if err := expectWrote(br); err != nil { fatal("after sig: %v", err) }

	writeLine(s, "COMMIT")
	if err := expectRebooting(br); err != nil { fatal("COMMIT: %v", err) }

	// local backup
	_ = os.MkdirAll("out", 0755)
	tag := time.Now().Format("20060102T150405")
	_ = os.WriteFile(filepath.Join("out", "license-"+tag+".json"), licBytes, 0644)
	_ = os.WriteFile(filepath.Join("out", "license-"+tag+".sig"),  sigB64,   0644)

	fmt.Println("\nprovision: DONE")
}

/* ====== reuse helpers ======
   Expect that functions below are defined in other files in the project and will be linked:
   - mustOpenSerial
   - writeLine, writeExact
   - readLineWithDuration
   - expectReady, expectWrote, expectOK, expectRebooting
   - waitFor
   - mustLoadPriv
   - sha256Hex
   If your project doesn't expose them globally, paste the implementations from your old file.
*/
